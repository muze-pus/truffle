const web3Utils = require("web3-utils");
const TestCase = require("mocha/lib/test.js");
const Suite = require("mocha/lib/suite.js");
const Deployer = require("@truffle/deployer");
const compile = require("@truffle/compile-solidity/legacy");
const abi = require("web3-eth-abi");
const path = require("path");
const semver = require("semver");
const Native = require("@truffle/compile-solidity/compilerSupplier/loadingStrategies/Native");
const util = require("util");
const debug = require("debug")("lib:testing:soliditytest");

let SafeSend;

const SolidityTest = {
  async define(abstraction, dependencyPaths, runner, mocha) {
    const self = this;

    const suite = new Suite(abstraction.contract_name, {});
    suite.timeout(runner.BEFORE_TIMEOUT);

    // Set up our runner's needs first.
    suite.beforeAll("prepare suite", async function() {
      await runner.initialize.bind(runner)();
      await self.compileNewAbstractInterface.bind(this)(runner);
      await self.deployTestDependencies.bind(
        this
      )(abstraction, dependencyPaths, runner);
    });

    suite.beforeEach("before test", async function() {
      await runner.startTest(this);
    });

    // Function that decodes raw logs from unlinked third party assertion
    // libraries and returns usable TestEvent logs
    function decodeTestEvents(result) {
      if (result.logs.length) return result.logs;

      const logs = [];
      const signature = web3Utils.sha3("TestEvent(bool,string)");

      for (const log of result.receipt.logs) {
        if (log.topics.length === 2 && log.topics[0] === signature) {
          const decoded = {
            event: "TestEvent",
            args: {
              result: abi.decodeLog(["bool"], log.topics[1], log.topics)[0],
              message: abi.decodeLog(["string"], log.data, log.topics)[0]
            }
          };
          logs.push(decoded);
        }
      }
      return logs;
    }

    // Function that checks transaction logs to see if a test failed.
    function processResult(result) {
      result.logs = decodeTestEvents(result);

      for (const log of result.logs) {
        if (log.event === "TestEvent" && !log.args.result) {
          throw new Error(log.args.message);
        }
      }
    }

    // Add functions from test file.
    for (const item of abstraction.abi) {
      if (item.type !== "function") {
        continue;
      }

      const hookTypes = ["beforeAll", "beforeEach", "afterAll", "afterEach"];
      for (const hookType of hookTypes) {
        if (item.name.startsWith(hookType)) {
          suite[hookType](item.name, async () => {
            let deployed = await abstraction.deployed();
            return processResult(await deployed[item.name]());
          });
        }
      }

      if (item.name.startsWith("test")) {
        const test = new TestCase(item.name, async () => {
          let deployed = await abstraction.deployed();
          return processResult(await deployed[item.name]());
        });

        test.timeout(runner.TEST_TIMEOUT);
        suite.addTest(test);
      }
    }

    suite.afterEach("after test", async function() {
      await runner.endTest(this);
    });

    mocha.suite.addSuite(suite);
  },

  async compileNewAbstractInterface(runner) {
    debug("compiling");
    const config = runner.config;
    const solcVersion = config.compilers.solc.version;
    if (solcVersion === "native") {
      solcVersion = new Native().load().version();
    }
    if (!solcVersion) {
      SafeSend = "NewSafeSend.sol";
    } else if (semver.lt(semver.coerce(solcVersion), "0.5.0")) {
      SafeSend = "OldSafeSend.sol";
    } else {
      SafeSend = "NewSafeSend.sol";
    }

    //HACK: promisify seems to lose context, so we explicitly bind compile
    const contracts = await util.promisify(
      compile.with_dependencies.bind(compile)
    )(
      runner.config.with({
        paths: [
          path.join(__dirname, "Assert.sol"),
          path.join(__dirname, "AssertAddress.sol"),
          path.join(__dirname, "AssertAddressArray.sol"),
          // path.join(__dirname, "AssertAddressPayableArray.sol"), only compatible w/ ^0.5.0
          path.join(__dirname, "AssertBalance.sol"),
          path.join(__dirname, "AssertBool.sol"),
          path.join(__dirname, "AssertBytes32.sol"),
          path.join(__dirname, "AssertBytes32Array.sol"),
          path.join(__dirname, "AssertGeneral.sol"),
          path.join(__dirname, "AssertInt.sol"),
          path.join(__dirname, "AssertIntArray.sol"),
          path.join(__dirname, "AssertString.sol"),
          path.join(__dirname, "AssertUint.sol"),
          path.join(__dirname, "AssertUintArray.sol"),
          "truffle/DeployedAddresses.sol", // generated by deployed.js
          path.join(__dirname, SafeSend)
        ],
        quiet: true
      })
    );

    // Set network values.
    for (const name in contracts) {
      contracts[name].network_id = config.network_id;
      contracts[name].default_network = config.default_network;
    }

    await config.artifactor.saveAll(contracts);
    debug("compiled");
  },

  async deployTestDependencies(abstraction, dependencyPaths, runner) {
    debug("deploying %s", abstraction.contract_name);
    const deployer = new Deployer(
      runner.config.with({
        logger: { log() {} }
      })
    );

    debug("starting deployer");
    await deployer.start();

    const testLibraries = [
      "Assert",
      "AssertAddress",
      "AssertAddressArray",
      //      "AssertAddressPayableArray", only compatible w/ ^0.5.0
      "AssertBalance",
      "AssertBool",
      "AssertBytes32",
      "AssertBytes32Array",
      "AssertGeneral",
      "AssertInt",
      "AssertIntArray",
      "AssertString",
      "AssertUint",
      "AssertUintArray",
      "DeployedAddresses"
    ];

    const testAbstractions = testLibraries.map(name =>
      runner.config.resolver.require(`truffle/${name}.sol`)
    );

    SafeSend = runner.config.resolver.require(SafeSend);

    debug("deploying test libs");
    for (const testLib of testAbstractions) {
      await deployer.deploy(testLib);
      await deployer.link(testLib, abstraction);
    }

    debug("linking dependencies");
    for (const dependencyPath of dependencyPaths) {
      const dependency = runner.config.resolver.require(dependencyPath);

      if (dependency.isDeployed()) {
        await deployer.link(dependency, abstraction);
      }
    }

    debug("deploying contract");
    await deployer.deploy(abstraction);
    const deployed = await abstraction.deployed();
    let balance;
    if (deployed.initialBalance) {
      balance = await deployed.initialBalance.call();
    } else {
      balance = 0;
    }

    if (balance !== 0) {
      await deployer.deploy(SafeSend, deployed.address, {
        value: balance
      });
      const safeSend = await SafeSend.deployed();
      await safeSend.deliver();
    }

    debug("deployed %s", abstraction.contract_name);
  }
};

module.exports = SolidityTest;
